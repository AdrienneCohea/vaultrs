# vaultrs

<p align="center">
    <a href="https://github.com/jmgilman/vaultrs/actions/workflows/validate.yml"><img src="https://github.com/jmgilman/vaultrs/actions/workflows/validate.yml/badge.svg"/></a>
    <a href="https://crates.io/crates/vaultrs"><img src="https://img.shields.io/crates/v/vaultrs"></a>
    <a href="https://docs.rs/vaultrs"><img src="https://img.shields.io/docsrs/vaultrs" /></a>
</p>

> A rust crate for interacting with the Hashicorp Vault API

This crate encompasses functions for interacting with the HTTP API available on
[Hashicorp Vault](https://www.vaultproject.io/) servers. It uses 
[rustify](https://github.com/jmgilman/rustify) in order to construct accurate
representations of each of the endpoints available with the API. It then wraps
these into more usable functions intended to be consumed by users of this crate.

The following functionality is currently supported:

* [KV Secrets Engine V2](https://www.vaultproject.io/docs/secrets/kv/kv-v2)
* [PKI Secrets Engine](https://www.vaultproject.io/docs/secrets/pki)
* [Response Wrapping](https://www.vaultproject.io/docs/concepts/response-wrapping)

## Installation

```
cargo add vaultrs
```

## Usage

### Basic

The client is used to configure the connection to Vault and is required to be
passed to all API calls for execution. 

```rust
use vaultrs::client::{VaultClient, VaultClientSettingsBuilder};

// Create a client
let client = VaultClient::new(
    VaultClientSettingsBuilder::default()
        .address("https://127.0.0.1:8200")
        .token("TOKEN")
        .build()
        .unwrap()
).unwrap();
```

### Secrets

The library currently supports all operations available for version 2 of the
key/value store. 

```rust
use vaultrs::kv2;

// Create and read secrets
struct MySecret {
    key: String,
    password: String,
}

let secret = MySecret {
    key: "super".to_string(),
    password: "secret".to_string(),
};
kv2::set(
    &client,
    "secret",
    "mysecret",
    &secret,
);

let secret = kv2::read::<MySecret>(&client, "secret" "mysecret").unwrap();
println!("{}", secret.password) // "secret"
```

### PKI

The library currently supports all operations available for the PKI secrets 
engine.

```rust
use vaultrs::pki::cert;
use vaultrs::api::pki::requests::GenerateCertificateRequest;

// Generate a certificate using the PKI backend
let cert = cert::generate(
    &client,
    "pki",
    "my_role",
    Some(GenerateCertificateRequest::builder().common_name("test.com")),
).unwrap();
println!("{}", cert.certificate) // "{PEM encoded certificate}"
```

### Wrapping

All requests implement the ability to be 
[wrapped](https://www.vaultproject.io/docs/concepts/response-wrapping). These
can be passed in your application internally before being unwrapped. 

```rust
use vaultrs::api::ResponseWrapper;
use vaulrs::api::sys::requests::ListMountsRequest;

let endpoint = ListMountsRequest::builder().build().unwrap();
let wrap_resp = endpoint.wrap(&client); // Wrapped response
assert!(wrap_resp.is_ok());

let wrap_resp = wrap_resp.unwrap(); // Unwrap Result<>
let info = wrap_resp.lookup(&client); // Check status of this wrapped response
assert!(info.is_ok());

let unwrap_resp = wrap_resp.unwrap(&client); // Unwrap the response
assert!(unwrap_resp.is_ok());

let info = wrap_resp.lookup(&client); // Error: response already unwrapped
assert!(info.is_err());
```

## Error Handling

All errors generated by this crate are wrapped in the `ClientError` enum 
provided by the crate. API warninings are automatically captured via `log` and
API errors are captured and returned as their own variant. Connection related
errors from `rusify` are wrapped and returned as a single variant.

## Testing

See the the [tests](tests) directory for tests. Run tests with `cargo test`.

**Note**: All tests rely on bringing up a local Vault development server using
Docker. The Docker CLI must be installed on the machine running the tests and
you must have permission to start new containers. 

## Contributing

1. Fork it (https://github.com/jmgilman/vaultrs/fork)
2. Create your feature branch (git checkout -b feature/fooBar)
3. Commit your changes (git commit -am 'Add some fooBar')
4. Push to the branch (git push origin feature/fooBar)
5. Create a new Pull Request

The largest need in terms of contributions is adding support for more endpoints
offered by the Vault API. Luckily, a lot of the work involved with configuring
the endpoints is abstracted away by 
[rustify](https://github.com/jmgilman/rustify). Additionally, enough endpoints
have already been created and so incorporating new ones often means copying
existing ones. 

### Architecture

The architecture of the source directory is as such:

* `src/` - Crate root directory
* `src/api` - Root directory containing raw endpoints and supporting functions
* `src/client.rs` - Source for the client
* `src/error.rs` - Contains the common error enum for this crate
* `src/lib.rs` - Crate root file
* `src/*.rs` - Main API functions that wrap endpoints located in `src/api`

For example, the PKI engine is organized as such:

* `src/api/pki/requests.rs` - Contains all endpoints associated with this engine
* `src/api/pki/responses.rs` - Contains all responses from the endpoints
* `src/pki.rs` - Contains the high level functions for interacting with the engine

Aditionally, the `src/pki.rs` file is further organized into modules which help
break up the API functions available. For example, `pki::certs` contains
functions for working with certificates and `pki::roles` contains functions for
configuring roles. 

### Adding functionality

1. Create a new directory under `src/api` for the engine type if it's not
   already been added.
2. Add endpoints to `src/api/{engine}/requests.rs` and their associated
   responses to `src/api/{engine}/responses.rs`.
3. Add high level functions that use the endpoints in `src/{engine}.rs`. 
4. Add tests for each high level function in `tests/{engine}.rs`. 

See existing endpoints for examples on how to configure and document them. For
additional information see the 
[rustify documentation](https://docs.rs/rustify/0.1.0/rustify/).

All tests use a live instance of the Vault server for testing against since
mocking cannot verify the endpoint structures are accurate and valid. This also 
allows pinning to specific versions of Vault and adding support for newer 
versions as needed. While the tests are not intended to test the Vault server 
itself, it's recommended to  perform necessary setup to imitate end-user
behavior.

Bear in mind that the response of an endpoint may change based on the input
given by the user. For example, a different response is generated by the root
CA generation endpoint depending on if an internal or external CA is requested.
It's therefore important to mark fields as `Optional<>` where necessary. 

The underlying API functions will handle most errors for you and all that should
be needed is to propogate them up the stack. 